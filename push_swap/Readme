

ä½¿ç”¨çš„ç®—æ³•ï¼š
CHUNK + GREEDY
La mÃ©thode **CHUNK + GREEDY** pour le projet **push\_swap** est une stratÃ©gie efficace pour trier les nombres en utilisant les deux piles `a` et `b`. Elle combine la division en **groupes (chunks)** avec une logique **greedy (avide)** pour optimiser le nombre de mouvements.
å°†æ‰€ç»™çš„æ•°æ®å‚¨å­˜åœ¨å †æ ˆAï¼Œ åŒæ—¶å»ºç«‹ä¸€ä¸ªå¤‡ç”¨çš„ç©ºå †æ ˆï¼Œ  ä½¿ç”¨CHUNKï¼Œ å°†æ•°æ®åˆ†æ‰¹ä»å †æ ˆAè½¬ç§»åˆ°å †æ ˆBï¼Œ ç„¶ååˆ©ç”¨ GREEDY çš„ç®—æ³•ï¼Œ å°†æ•°æ®ä»å †æ ˆBè½¬ç§»åˆ°å †æ ˆAï¼Œ é€‰æ‹©æœ€èŠ‚çœæ­¥æ•°çš„å…ƒç´ é€æ­¥è¿ç§»ï¼Œ å †æ ˆB ç©ºå‡ºåï¼Œ æŠŠå †æ ˆA ä¸­æœ€å°å€¼å¾€åçš„æ•°æ®åè½¬åˆ°æ­£ç¡®çš„ä½ç½®ï¼Œ å¤§åŠŸå‘Šæˆï¼

## ğŸ§© 1. CHUNK + GREEDY :

### âœ… Objectif :

* Diviser les nombres en **plus petits groupes (chunks)**.
å°†ç»™å‡ºçš„æ•°æ®åˆ†æˆå¤šä¸ªå°ç»„
* Pousser ces groupes de `a` vers `b` progressivement.
æŠŠAä¸­çš„å°ç»„é€æ­¥æ¨é€åˆ°B
* Puis remonter les Ã©lÃ©ments de `b` vers `a` dans lâ€™ordre correct.
æŠŠBä¸­çš„å„ä¸ªå…ƒç´ æ¨å›åˆ°Aã€‚ 

## ğŸ”¹ 2. Ã‰tapes de lâ€™algorithme
ç®—æ³•ï¼š

### ğŸ¥‡ Ã‰tape 1 : CrÃ©er un tableau triÃ© å°†ç»™å‡ºçš„æ•°æ®åˆ›å»ºæˆä¸€ä¸ªæ•°æ®é“¾è¡¨ï¼Œ æŒ‰å¤§å°é¡ºåºç»™åˆ«èµ‹äºˆå…¶INDEX
t_list	*parse_list(int argc, char **argv)
void	assign_indexes(t_list *lst)

### ğŸ§± Ã‰tape 2 : DÃ©couper en **chunks**
æŠŠAä¸­çš„å…ƒç´ åˆ†æˆå°ç»„ï¼Œ é€æ­¥æ¨åˆ°Bï¼Œ åŒæ—¶å°†æ¨åˆ°Bä¸­çš„æ¯”ä¸­é—´å€¼å°çš„å…ƒç´ åè½¬åˆ°ä¸‹æ–¹ï¼Œ ä»¥å‡å°‘ä»¥åæ’åºçš„æ¬¡æ•°
Choisis un **nombre de chunks** selon la taille de la pile :

| Taille de la pile | Chunks recommandÃ©s |
| ----------------- | ------------------ |
| 100               | 5 Ã  20             |
| 500               | 10 Ã  40            |


### ğŸšš Ã‰tape 3 : Push les chunks vers la pile B
int	move_to_b(t_list **list_a, t_list **list_b, int limit, int chunk_size)
Tu parcours la pile `a` :
éå†å †æ ˆA

* Si un Ã©lÃ©ment appartient au **chunk courant**, tu le `pb` (push vers `b`).
å¦‚æœæ­¤å…ƒç´ å±äºå½“å‰çš„å †æ ˆï¼Œ åˆ™æ‰§è¡Œpb, å°†æ­¤å…ƒç´ æ¨åˆ°å †æ ˆB
* Tu choisis de le mettre en haut ou en bas de `b` selon sa **valeur** (greedy) :
åœ¨å †æ ˆBä¸­ï¼Œ æ ¹æ®æ­¤å…ƒç´ çš„INDEX å¤§å°ï¼Œ å†³å®šæ˜¯å¦åè½¬å…¶ä½ç½®
  * Si sa **valeur est petite** â†’ `pb`
  * Si sa **valeur est grande** â†’ `pb` + `rb` (remettre en bas pour mieux le trier plus tard)

Cela permet de **prÃ©parer `b` dans un ordre partiellement triÃ©**, ce qui rend le retour vers `a` plus rapide.

### ğŸ” Ã‰tape 4 : Remonter `b` vers `a` (tri final)
å°†å…ƒç´ ä»B è½¬ç§»åˆ°A

ç›®æ ‡æ˜¯æŠŠBä¸­çš„å…ƒç´ æ”¾ç½®åˆ°Aä¸­æ¯”å®ƒå¤§çš„å…ƒç´ ä¸­æœ€å°çš„é‚£ä¸ªå€¼çš„ä¸Šé¢çš„ä½ç½®ã€‚ ä¸ºæ­¤éœ€è¦è®¡ç®—åœ¨Bä¸­å…ƒç´ ä¸­è¾¾åˆ°æ­¤ç›®æ ‡éœ€è¦æ­¥æ•°æœ€å°‘çš„é‚£ä¸ªå…ƒç´ å®è¡Œæ­¤æ“ä½œã€‚ 
t_move	*get_move(t_list *a, t_list *b, t_list *tmp, t_move *best)
t_move	*get_best_move(t_list *a, t_list *b)
int	execute_move(t_list **a, t_list **b, t_move *move)
int	greedy_sort(t_list **a, t_list **b)

### ğŸ” Ã‰tape 5 : remonter les elements en dessous le element plus petit en haut (tri final)
æœ€åæŠŠæœ€å°å…ƒç´ åŠå…¶æ’åˆ—åœ¨å…¶ä¸‹é¢çš„å…ƒç´ åè½¬åˆ°ä¸Šé¢ã€‚ 
int	rotate_to_min(t_list **a)


å®‰è£…ä»¥ä¸‹çš„æµ‹è¯•ç¨‹åºå¯ä»¥æ–¹ä¾¿å¤§æ‰¹é‡ï¼š
https://github.com/anonylouis/42Project---Push_swap-Tester
https://github.com/o-reo/push_swap_visualizer
https://github.com/SimonCROS/push_swap_tester

